# ansible-galaxy collection install community.general ansible.posix kubernetes.core
---
- name: Prepare for elasticsearch containers
  # gather_facts: true
  hosts: all
  roles:
   - baremetal-elasticsearch
   - baremetal-containerd
   - baremetal-kubernetes
   - cni
   - tools
   - csi
   - loadbalancer
   - externaldns
   - ingress
   - dashboard
# TODO: Make ldap declarative
- name: Deploy LDAP
  gather_facts: true
  hosts: main
  vars:
    LDAP_BASE_DN: "{{'{{ LDAP_BASE_DN }}'}}"
    LDAP_DOMAIN: "{{'{{ LDAP_DOMAIN }}'}}"
    LDAP_READONLY_USER_USERNAME: "{{'{{ LDAP_READONLY_USER_USERNAME }}'}}"
    LDAP_READONLY_USER_PASSWORD_ENCRYPTED: "{{'{{ LDAP_READONLY_USER_PASSWORD_ENCRYPTED }}'}}"
    tld_hostname: home.arpa
    ldap:
      ldif: "{{ lookup('template', './values/ldap.ldif') }}"
      namespace: infrastructure
      organization: "My Company"
      openldap:
        releaseName: openldap
      phpldapadmin:
        releaseName: phpldapadmin
  vars_prompt:
    - name: admin_password
      default: "secret"
      private: yes
      prompt: Ldap admin password
  tasks:
    - kubernetes.core.helm_repository:
        name: "{{ item.name }}"
        repo_url: "{{ item.url }}"
      with_items:
        - name: stable
          url: https://charts.helm.sh/stable
        - name: cetic
          url: https://cetic.github.io/helm-charts
    - kubernetes.core.helm:
        name: dummy
        namespace: kube-system
        state: absent
        update_repo_cache: true
    - kubernetes.core.helm:
        name: "{{ item.name }}"
        create_namespace: true
        chart_ref: "{{ item.chartRef }}"
        release_namespace: "{{ ldap.namespace }}"
        values: "{{ lookup('template', './values/ldap-{{ item.name }}.yml') | from_yaml }}"
      with_items:
        - name: "{{ ldap.phpldapadmin.releaseName }}"
          chartRef: cetic/phpldapadmin
        - name: "{{ ldap.openldap.releaseName }}"
          chartRef: stable/openldap
    - kubernetes.core.k8s:
        state: present
        definition:
          apiVersion: networking.k8s.io/v1
          kind: Ingress
          metadata:
            name: phpldapadmin-ingress
            namespace: "{{ ldap.namespace }}"
            annotations:
              kubernetes.io/ingress.class: "nginx"
              cert-manager.io/cluster-issuer: ca-issuer
          spec:
            rules:
              - host: "ldap-admin.{{ tld_hostname }}"
                http:
                  paths:
                    - backend:
                        service:
                          name: "{{ ldap.phpldapadmin.releaseName }}"
                          port:
                            number: 80
                      pathType: ImplementationSpecific
            tls:
              - hosts:
                  - "ldap-admin.{{ tld_hostname }}"
                secretName: ldap-admin-tls
- name: Deploy monitoring
  gather_facts: false
  hosts: main
  vars:
    monitoring:
      namespace: infrastructure
    opensearch:
      opensearch-dashboards:
        name: opensearch
    tld_hostname: home.arpa
  tasks:
    - kubernetes.core.helm_repository:
        name: "{{ item.name }}"
        repo_url: "{{ item.url }}"
      with_items:
        - name: grafana
          url: https://grafana.github.io/helm-charts
        - name: loki
          url: https://grafana.github.io/loki/charts
        - name: prometheus-community
          url: https://prometheus-community.github.io/helm-charts
        - name: opensearch
          url: https://opensearch-project.github.io/helm-charts
    - kubernetes.core.helm:
        name: dummy
        namespace: kube-system
        state: absent
        update_repo_cache: true
    - kubernetes.core.helm:
        name: "{{ item.release_name }}"
        create_namespace: true
        chart_ref: "{{ item.repository }}"
        release_namespace: "{{ monitoring.namespace }}"
        values: "{{ lookup('template', './values/monitoring-{{ item.release_name }}.yaml') | from_yaml }}"
      with_items:
        - release_name: grafana
          repository: grafana/grafana
        - release_name: loki
          repository: loki/loki
        - release_name: prometheus
          repository: prometheus-community/prometheus
        - release_name: promtail
          repository: loki/promtail
        - release_name: "opensearch"
          repository: "opensearch/opensearch"
        - release_name: opensearch-dashboards
          repository: "opensearch/opensearch-dashboards"
    # TODO: Handle ingress for prometheus via Helm chart
    - kubernetes.core.k8s:
        state: present
        definition:
          apiVersion: networking.k8s.io/v1
          kind: Ingress
          metadata:
            name: grafana
            namespace: "{{ monitoring.namespace }}"
            annotations:
              kubernetes.io/ingress.class: "nginx"
              cert-manager.io/cluster-issuer: ca-issuer
          spec:
            tls:
              - hosts:
                  - "grafana.{{ tld_hostname }}"
                secretName: "grafana-tls"
            rules:
              - host: "grafana.{{ tld_hostname }}"
                http:
                  paths:
                    - backend:
                        service:
                          name: grafana
                          port:
                            number: 80
                      pathType: ImplementationSpecific
- name: Deploy cert manager
  gather_facts: true
  hosts: main
  vars:
    INTERMEDIATE_CA_FILENAME: company-intermediate-ca
    certmanager:
      namespace: "infrastructure"
      name: cert-manager
  tasks:
    - kubernetes.core.helm_repository:
        name: jetstack
        repo_url: https://charts.jetstack.io
    - kubernetes.core.helm:
        create_namespace: true
        update_repo_cache: true
        name: "{{ certmanager.name }}"
        chart_ref: jetstack/cert-manager
        release_namespace: "{{ certmanager.namespace }}"
        values:
          installCRDs: true
    - kubernetes.core.k8s:
        state: present
        definition:
          apiVersion: cert-manager.io/v1
          kind: ClusterIssuer
          metadata:
            name: ca-issuer
            namespace: "{{ certmanager.namespace }}"
          spec:
            ca:
              secretName: ca-key-pair
    - name: Create temporary build directory
      ansible.builtin.tempfile:
        state: directory
        suffix: certs
      register: tempdir
    # Rewrite as Ansible
    - become: true
      ansible.builtin.shell:
        chdir: "{{ tempdir.path }}"
        cmd: |
          #!/bin/bash

          set -e

          CA_PATH="/etc/kubernetes/pki"

          # Generate key for intermediate CA
          #  -aes256 to protect it with passphrase
          openssl genrsa -out "{{INTERMEDIATE_CA_FILENAME}}.key" 4096

          cat <<EOF > openssl.cnf
          [req]
          req_extensions = v3_req
          # req_extensions = v3_intermediate_ca
          # x509_extensions = v3_req
          x509_extensions = v3_intermediate_ca
          distinguished_name = req_distinguished_name
          prompt = no

          [ v3_req ]
          extendedKeyUsage = serverAuth, clientAuth, codeSigning, emailProtection
          basicConstraints = critical,CA:TRUE
          keyUsage = nonRepudiation, digitalSignature, keyEncipherment

          [req_distinguished_name]
          countryName            = PL
          stateOrProvinceName    = Mazovia
          localityName           = Pruszkow
          organizationName       = Home
          commonName             = home.arpa intermediate CA
          emailAddress           = jacek.lipiec.bc@gmail.com

          [ v3_intermediate_ca ]
          subjectKeyIdentifier = hash
          authorityKeyIdentifier = keyid:always,issuer
          basicConstraints = critical,CA:true,pathlen:0
          keyUsage = critical,digitalSignature,cRLSign, keyCertSign
          EOF

          # Generate itermediate CSR for home.arpa
          openssl req \
              -config openssl.cnf \
              -new \
              -sha256 \
              -newkey rsa:2048 \
              -nodes \
              -key "{{INTERMEDIATE_CA_FILENAME}}.key" \
              -out "{{INTERMEDIATE_CA_FILENAME}}.csr"

          # Sign request with kubernetes
          openssl x509 \
              -req \
              -in "{{INTERMEDIATE_CA_FILENAME}}.csr" \
              -CA "${CA_PATH}/ca.crt" \
              -CAkey "${CA_PATH}/ca.key" \
              -extensions v3_intermediate_ca \
              -CAcreateserial \
              -extfile openssl.cnf \
              -out "{{INTERMEDIATE_CA_FILENAME}}.crt" \
              -days 500 \
              -sha512

          cat "{{INTERMEDIATE_CA_FILENAME}}.crt" "${CA_PATH}/ca.crt" > chain.crt
          chown {{ansible_env.LOGNAME}} chain.crt "{{INTERMEDIATE_CA_FILENAME}}.key"
    - ansible.builtin.shell:
        chdir: "{{ tempdir.path }}"
        cmd: |
          kubectl create secret generic \
              --namespace "{{ certmanager.namespace }}" \
              ca-key-pair \
              --from-file=tls.crt=./chain.crt \
              --from-file=tls.key={{INTERMEDIATE_CA_FILENAME}}.key
    - name: Use the registered var and the file module to remove the temporary file
      ansible.builtin.file:
        path: "{{ tempdir.path }}"
        state: absent
      when: tempdir.path is defined
- name: Deploy Gerrit
  gather_facts: false
  hosts: all
  vars:
    HTTPD_LISTEN_URL: "proxy-https://*:8080/"
    TEMP_DIRECTORY: "/tmp/gerrit"
    LDAP_SERVER: "ldap://openldap"
    LDAP_DC: "dc=home,dc=arpa"
    gerrit:
      release_name: gerrit
      namespace: infrastructure
    tld_hostname: home.arpa
    storageClass: freenas-nfs-csi
  tasks:
    - ansible.builtin.tempfile:
        state: directory
        suffix: certs
      register: tempdir
    - ansible.builtin.git:
        repo: https://github.com/GerritCodeReview/k8s-gerrit.git
        dest: "{{tempdir.path}}"
    - kubernetes.core.helm:
        create_namespace: true
        name: "{{gerrit.release_name}}"
        chart_ref: "{{tempdir.path}}/helm-charts/gerrit"
        release_namespace: "{{ gerrit.namespace }}"
        values: "{{ lookup('template', './values/gerrit-values.yml') | from_yaml }}"
    - kubernetes.core.k8s:
        state: patched
        name: gerrit-gerrit-ingress
        namespace: gerrit
        kind: Ingress
        definition:
          spec:
            rules:
              #- host: ssh.gerrit.home.arpa
              #  http:
              #    paths:
              #    - backend:
              #        service:
              #          name: gerrit-gerrit-service
              #          port:
              #            number: 29418
              #      path: /
              #      pathType: ImplementationSpecific
              - host: gerrit.home.arpa
                http:
                  paths:
                    - backend:
                        service:
                          name: gerrit-gerrit-service
                          port:
                            number: 80
                      path: /
                      pathType: Prefix
            tls:
              - hosts:
                  - gerrit.home.arpa
                #- ssh.gerrit.home.arpa
                secretName: gerrit-tls
    - name: Annotate service with external hostname
      command: |
        kubectl annotate Service {{gerrit.release_name}}-gerrit-service \
          --namespace={{ gerrit.namespace }} \
          --overwrite external-dns.alpha.kubernetes.io/hostname="ssh.{{gerrit.release_name}}.{{tld_hostname}}"
    - ansible.builtin.file:
        path: "{{ tempdir.path }}"
        state: absent
      when: tempdir.path is defined
- name: Deploy Jenkins
  gather_facts: false
  hosts: main
  vars:
    # GERRIT_SERVER: "gerrit-service-gerrit.gerrit"
    tld_hostname: "home.arpa"
    cluster_zone: cluster.local
    jenkins:
      namespace: "infrastructure"
      release_name: "jenkins"
      ldap:
        server: "ldap://openldap"
        root_dn: "dc=home,dc=arpa"
        ldap_user: "readonly"
        jenkins_ldap_username: "jenkins"
  vars_prompt:
    - name: ldap_password
      default: "readonly"
      prompt: Ldap user password
      private: true
    - name: jenkins_ldap_password
      default: "jenkins"
      private: false
  tasks:
    - kubernetes.core.helm_repository:
        name: jenkins
        repo_url: https://charts.jenkins.io
    - kubernetes.core.helm:
        chart_version: "4.2.14"
        create_namespace: true
        update_repo_cache: true
        name: "{{ jenkins.release_name }}"
        chart_ref: jenkins/jenkins
        release_namespace: "{{ jenkins.namespace }}"
        values: "{{ lookup('template', './values/jenkins-values.yml') | from_yaml }}"
    # ssh-keygen -b 2048 -t rsa -f ./sshkey -q -N '' <<<y && ssh-keygen -y -f ./sshkey > ./sshkey.pub
    - name: Generate SSH key
      shell: "ssh-keygen {{item}}"
      args:
        executable: /usr/bin/bash
      with_items:
        - "-b 2048 -t rsa -f {{TEMP_DIRECTORY}}/sshkey -q -N '' <<<y 2>&1 >/dev/null"
        - "-y -f {{TEMP_DIRECTORY}}/sshkey > {{TEMP_DIRECTORY}}/sshkey.pub"
    - name: Create ldap secret
      command: kubectl apply -f {{ TEMP_DIRECTORY }}/ldap-password
    - name: Create gerrit ssh secret
      command: "kubectl create secret generic gerrit-ssh --from-file=ssh-privatekey={{TEMP_DIRECTORY}}/sshkey --namespace={{ namespace }}"
    - name: Add helm repository
      command: helm repo add jenkins https://charts.jenkins.io
    - name: Update helm repositories
      command: helm repo update
    - name: Deploy helm charts
      args:
        executable: /usr/bin/bash
      shell:
        cmd: |
          helm upgrade --install \
            --namespace={{ namespace }} --create-namespace \
            --values={{TEMP_DIRECTORY}}/values.yaml \
            {{ release_name }} \
            jenkins/jenkins
    - name: Create ldap secret
      shell: 'kubectl patch StatefulSet/jenkins --namespace=jenkins --patch "$(cat {{TEMP_DIRECTORY}}/{{item}})"'
      with_items:
        - gerrit-ssh.patch
        - ldap-password.patch
      # Gerrit
    - name: Create jenkins basicauth
      command: "printf 'Authorization: Basic {{ (jenkins_ldap_username + jenkins_ldap_password) | string | b64encode }}'"
      register: basic_auth
    - name: Get public key
      command: "cat {{TEMP_DIRECTORY}}/sshkey.pub"
      register: sshkey_pub
    - name: Act on gerrit
      command: "curl --request POST --show-error --header 'Authorization: Basic {{basic_auth.stdout}}' --header 'Content-Type: {{item.header}}' --data '{{item.data}}' https:/gerrit.{{ domain }}/{{item.url}}"
      with_items:
        - header: application:x-www-form-urlencoded
          data: username={{jenkins_ldap_username}}&password={{jenkins_ldap_password}}
          url: login
        - header: text/plain
          data: "{{sshkey_pub.stdout}}"
          url: a/accounts/self/sshkeys
    - name: Clean temp path
      become: true
      file:
        state: absent
        path: "{{ TEMP_DIRECTORY }}"
- name: Deploy services
  gather_facts: false
  hosts: main
  vars:
    ldap:
      server: openldap
      port: "389"
    tld_hostname: home.arpa
    infrastructure:
      namespace: "infrastructure"
  tasks:
    - name: Install ArgoCD
      vars:
        argocd:
          namespace: "{{infrastructure.namespace}}"
      include_role:
        name: argocd

## CERTS=/opt/bitnami/etcd/certs/client; etcdctl --cacert=${CERTS}/ca.pem --key=${CERTS}/client-key.pem --cert=${CERTS}/client.pem get / --prefix
